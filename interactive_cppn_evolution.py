"""
Code originally taken from the offline simplified version of Picbreeder
that comes with NEAT-Python. Just wanted a starting point for evolving CPPNs.
Modifying the code to apply to Minecraft.
"""
# Are these still needed?
from http import client
import math
import os
import pickle

# For CPPNs and NEAT
import neat
import custom_genomes as cg

# for Minecraft
import grpc
import minecraft_pb2_grpc
from minecraft_pb2 import *

# For utility functions
import util

# For minecraft structures
import minecraft_structures

# For InteractiveStagnation class
import neat_stagnation

class MinecraftBreeder(object):
    def __init__(self, args, block_list):
        """
        Construct a class for evolving Minecraft shapes
        interactively. The shapes are generated by CPPNs.

        Parameters:
        args (argparse.Namespace): Command line parameter bundle
        block_list ([int]): List where each int represents a Minecraft block type.
                            This will be empty if block lists are maintained within
                            each genome rather than shared among them.
        """
        self.args = args
        self.block_list = block_list

        self.position_information = dict()
        self.position_information["startx"] = 0
        self.position_information["starty"] = 5
        self.position_information["startz"] = 0
        self.position_information["xrange"] = self.args.XRANGE
        self.position_information["yrange"] = self.args.YRANGE
        self.position_information["zrange"] = self.args.ZRANGE

        # Connect to Minecraft server
        channel = grpc.insecure_channel('localhost:5001')
        self.client = minecraft_pb2_grpc.MinecraftServiceStub(channel)

        # Restore ground at the start of evolution
        minecraft_structures.restore_ground(self.client, self.position_information, self.args.POPULATION_SIZE, self.args.SPACE_BETWEEN)

        # Figure out the lower corner of each shape in advance
        self.corners = []
        for n in range(self.args.POPULATION_SIZE):
            corner = (self.position_information["startx"] + n*(self.position_information["xrange"]+2+self.args.SPACE_BETWEEN), self.position_information["starty"], self.position_information["startz"])
            self.corners.append(corner)
            # Place the numbers just once. Only works for 0-9
            minecraft_structures.place_number(self.client,self.position_information,corner,n)

        self.generation = 0
        
        # Don't try any multithreading yet, but consider for later
        self.num_workers = 1

    def query_cppn_for_shape(self, genome, config, corner):
        """
        Query CPPN at all voxel coordinates to generate the list of
        blocks that will eventually be rendered in the Minecraft server.

        Parameters:
        genome (DefaultGenome): A CPPN or some class that extends CPPNs
        config (Config): NEAT configurations
        corner (int,int,int): three-tuple of initial/minimal x,y,z coordinates for shape

        Returns:
        [Block]:List of Blocks to generate in Minecraft
        """
        # If not evolving block list, use the static one specified lower in the code. Otherwise, use the genome's list
        if not self.args.BLOCK_LIST_EVOLVES:
            block_options = self.block_list
        else:
            block_options = genome.block_list

        net = neat.nn.FeedForwardNetwork.create(genome, config) # Create CPPN out of genome
        shape = []
        for xi in range(self.position_information["xrange"]):
            x = util.scale_and_center(xi,self.position_information["xrange"])
            for yi in range(self.position_information["yrange"]):
                y = util.scale_and_center(yi,self.position_information["yrange"])
                for zi in range(self.position_information["zrange"]):
                    z = util.scale_and_center(zi,self.position_information["zrange"])
                    # math.sqrt(2) is the usual scaling for radial distances in CPPNs
                    center_dist = util.distance((x,y,z),(0,0,0))
                    output = net.activate([x, y, z, center_dist * math.sqrt(2), 1.0])
                    
                    # First output determines whether there is a block at all.
                    # If there is a block, argmax determines the max value and places the specified block 
                    # from the list of possible blocks
                    presence_threshold = self.args.PRESENCE_THRESHOLD 
                    
                    if self.args.DISTANCE_PRESENCE_THRESHOLD == True:
                        presence_threshold = self.args.DISTANCE_PRESENCE_MULTIPLIER * center_dist                            

                    # Only generate non-air blocks
                    if output[0] >= presence_threshold: 
                        output_val = util.argmax(output[1:])
                        assert (output_val >= 0 and output_val < len(block_options)),"{} out of bounds: {}".format(output_val,block_options)
                        block = Block(position=Point(x=corner[0]+xi, y=corner[1]+yi, z=corner[2]+zi), type=block_options[output_val], orientation=NORTH)
                        shape.append(block)
        
        if(len(shape) == 0):
            print("Genome at corner {} is empty".format(corner))
        else:
            #print(list(BlockType.items()))
            #print(list(BlockType.keys()))
            print("Genome at corner {} generated {} blocks of these types: {}".format(corner,len(shape),set(map(lambda x: BlockType.keys()[x.type], shape))))

        return shape

    def eval_fitness(self, genomes, config):
        """
        This function is expected by the NEAT-Python framework.
        It takes a population of genomes and configuration information,
        and assigns fitness values to each of the genome objects in
        the population. Nothing is returned, since the genomes themselves
        are modified.
        
        Parameters:
        genomes ([DefaultGenome]): list of CPPN genomes
        config  (Config): NEAT configurations
        """            
        minecraft_structures.clear_area(self.client, self.position_information, self.args.POPULATION_SIZE, self.args.SPACE_BETWEEN)                                                                                                               
        selected = []
        
        # This loop could be parallelized
        for n, (genome_id, genome) in enumerate(genomes):
            # Initially, none are selected
            selected.append(False)
            if self.args.BLOCK_LIST_EVOLVES:
                minecraft_structures.place_blocks_in_block_list(genome.block_list,self.client,self.corners[n], self.position_information,n)
            # See how CPPN fills out the shape
            print("{}. {}: ".format(n,genome_id), end = "") # Preceding number before info from query
            shape = self.query_cppn_for_shape(genome, config, self.corners[n])
            # fill the empty space with the evolved shape
            self.client.spawnBlocks(Blocks(blocks=shape))
            # Place the fences where the shape will appear
            minecraft_structures.place_fences(self.client, self.position_information, self.corners[n])

        if self.args.IN_GAME_CONTROL:
            (on_block_positions,next_block_positions) = minecraft_structures.player_selection_switches(self.client, self.position_information, self.corners)

            selected = [False for _ in range(config.pop_size)]
            player_select_done = False
            
            while not player_select_done: #player is still selecting
               
                # constantly reads the position right below the redstone lamp
                # to see if the player has switched on a lever
                for i in range(config.pop_size):
                    first = on_block_positions[i]
                    blocks = self.client.readCube(Cube(
                        min=Point(x=first[0], y=first[1], z=first[2]),
                        max=Point(x=first[0], y=first[1], z=first[2])
                    ))
                    selected[i] = blocks.blocks[0].type == REDSTONE_BLOCK

                player_select_done = False
                j = 0
                # Checks the hidden Piston Heads associated with each next generation switch. 
                # If any one is sensed, then player selection is done 
                while not player_select_done and j < config.pop_size:
                    pressed = next_block_positions[j]
                    done_button = self.client.readCube(Cube(
                        min=Point(x=pressed[0], y=pressed[1], z=pressed[2]),
                        max=Point(x=pressed[0], y=pressed[1], z=pressed[2])
                    ))
                    player_select_done = done_button.blocks[0].type == PISTON_HEAD
                    j += 1
                    
                if self.args.BLOCK_LIST_EVOLVES:
                    # TODO: This will currently only work with in-game selection, but not with console-based selection. Need to fix.
                    read_current_blocks=minecraft_structures.read_current_block_options(self.client,self.corners,self.position_information)

                    for n, (_, genome) in enumerate(genomes):
                        if(not genome.block_list==read_current_blocks[n]):
                            for i in range(len(genome.block_list)):
                                if(not genome.block_list[i]==read_current_blocks[n][i]):
                                    genome.block_list[i]=read_current_blocks[n][i]

 
                #print(selected)

        else:
            # Controlled externally by keyboard

            # Creates a string that is the user's input, and the converts it to a list
            vals = input("Select the ones you like:")
            split_vals = vals.split(' ')
            selected_vals = list(map(int,split_vals))

            # Initialize to all False
            selected = [False for i in range(config.pop_size)]
            # Then set to True for the items that are selected
            for ind in selected_vals:
                selected[ind] = True
        
        print("Selected: {}".format(selected))

        for n, (genome_id, genome) in enumerate(genomes):
            if selected[n]:
                genome.fitness = 1.0
            else:
                genome.fitness = 0.0
            print("{}. {}: {}".format(n,genome_id,genome.fitness))

        if self.args.USE_ELITISM:
            # To assure that all selected individuals survive, the elitism setting is changed
            elite_count = int(sum(map(lambda b : 1 if b else 0, selected)))
            print("{} elite survivors".format(elite_count))
            config.reproduction_config.elitism = elite_count

    # End of MinecraftBreeder

# Various functions

def run(args):
    # If the block list evolves, customGenome is used. Otherwise it's the Default 
    if not args.BLOCK_LIST_EVOLVES:
        # Contains all possible blocks that could be placed, if the block list does not evolve, can be edited to have any blocks here
        block_list = [REDSTONE_BLOCK,PISTON,STONE, SLIME] # TODO: Make this a command line parameter somehow?
        genome_type = neat.DefaultGenome
        config_file = 'cppn_minecraft_config'
        block_list_length = len(block_list)
    else:
        block_list = [] # Won't be used, but parameter is still needed
        genome_type = cg.CustomBlocksGenome
        config_file = 'cppn_minecraft_custom_blocks_config'
        block_list_length = args.NUM_EVOLVED_BLOCK_LIST_TYPES
        cg.BLOCK_CHANGE_PROBABILITY = args.BLOCK_CHANGE_PROBABILITY
        #print("Set BLOCK_CHANGE_PROBABILITY to {}".format(cg.BLOCK_CHANGE_PROBABILITY))

    mc = MinecraftBreeder(args,block_list)

    # Determine path to configuration file.
    local_dir = os.path.dirname(__file__)
    config_path = os.path.join(local_dir, config_file)

    # Note that we provide the custom stagnation class to the Config constructor.
    config = neat.Config(genome_type, neat.DefaultReproduction,
                         neat.DefaultSpeciesSet, neat_stagnation.InteractiveStagnation,
                         config_path)

    config.pop_size = args.POPULATION_SIZE
    # Changing the number of CPPN outputs after initialization. Could cause problems.
    config.genome_config.num_outputs = block_list_length+1
    config.genome_config.output_keys = [i for i in range(config.genome_config.num_outputs)]

    pop = neat.Population(config)

    # Add a stdout reporter to show progress in the terminal.
    pop.add_reporter(neat.StdOutReporter(True))
    stats = neat.StatisticsReporter()
    pop.add_reporter(stats)

    # Evolve forever: TODO: Add use means of stopping
    try:
        while True:
            mc.generation = pop.generation + 1
            pop.run(mc.eval_fitness, 1)
    finally:
        # Clear and reset lots of extra space on exit/crash. Population size doubled to clear more space
        minecraft_structures.restore_ground(mc.client, mc.position_information, mc.args.POPULATION_SIZE*2, mc.args.SPACE_BETWEEN)
        minecraft_structures.clear_area(mc.client, mc.position_information, mc.args.POPULATION_SIZE*2, mc.args.SPACE_BETWEEN)                                                                                                               
        # Clear space in the air to get rid of numbers
        mc.position_information["starty"] = mc.position_information["starty"]+mc.position_information["yrange"]
        minecraft_structures.clear_area(mc.client, mc.position_information, mc.args.POPULATION_SIZE*2, mc.args.SPACE_BETWEEN)                                                                                                               

if __name__ == '__main__':
    print("Do not launch this file directly. Launch main.py instead.")