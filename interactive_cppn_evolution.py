"""
Code originally taken from the offline simplified version of Picbreeder
that comes with NEAT-Python. Just wanted a starting point for evolving CPPNs.
Modifying the code to apply to Minecraft.
"""
# For CPPNs and NEAT
import neat
import custom_genomes as cg

# for Minecraft
import grpc
import minecraft_pb2_grpc
from minecraft_pb2 import *

# For minecraft generation
import minecraft_structures
import block_sets

# For CPPN generations
import cppn_generation

class MinecraftBreeder(object):
    def __init__(self, args, block_list):
        """
        Construct a class for evolving Minecraft shapes
        interactively. The shapes are generated by CPPNs.

        Parameters:
        args (argparse.Namespace): Command line parameter bundle
        block_list ([int]): List where each int represents a Minecraft block type.
                            This will be empty if block lists are maintained within
                            each genome rather than shared among them.
        """
        self.args = args
        self.block_list = block_list

        self.position_information = dict()
        self.position_information["startx"] = 0
        self.position_information["starty"] = 5
        self.position_information["startz"] = 0
        self.position_information["xrange"] = self.args.XRANGE
        self.position_information["yrange"] = self.args.YRANGE
        self.position_information["zrange"] = self.args.ZRANGE

        # Connect to Minecraft server
        channel = grpc.insecure_channel('localhost:5001')
        self.client = minecraft_pb2_grpc.MinecraftServiceStub(channel)

        # Restore ground at the start of evolution
        minecraft_structures.restore_ground(self.client, self.position_information, self.args.POPULATION_SIZE, self.args.SPACE_BETWEEN)

        # Figure out the lower corner of each shape in advance
        self.corners = []
        for n in range(self.args.POPULATION_SIZE):
            corner = (self.position_information["startx"] + n*(self.position_information["xrange"]+2+self.args.SPACE_BETWEEN), self.position_information["starty"], self.position_information["startz"])
            self.corners.append(corner)
            # Place the numbers just once. Only works for 0-9
            minecraft_structures.place_number(self.client,self.position_information,corner,n)

        self.generation = 0
        
        # Don't try any multithreading yet, but consider for later
        self.num_workers = 1


    def eval_fitness(self, genomes, config):
        """
        This function is expected by the NEAT-Python framework.
        It takes a population of genomes and configuration information,
        and assigns fitness values to each of the genome objects in
        the population. Nothing is returned, since the genomes themselves
        are modified.
        
        Parameters:
        genomes ([DefaultGenome]): list of CPPN genomes
        config  (Config): NEAT configurations
        """            
        minecraft_structures.clear_area(self.client, self.position_information, self.args.POPULATION_SIZE, self.args.SPACE_BETWEEN)                                                                                                               
        selected = []
        
        #print(block_sets.select_possible_block_sets(self.args.POTENTIAL_BLOCK_SET))
        # This loop could be parallelized
        for n, (genome_id, genome) in enumerate(genomes):
            # Initially, none are selected
            selected.append(False)
            
            
            # See how CPPN fills out the shape
            print("{}. {}: ".format(n,genome_id), end = "") # Preceding number before info from query
            # If EVOLVE_SNAKE is true, it will generate a snake,
            # otherwise it will create the normal structures
            if self.args.EVOLVE_SNAKE:
                shape = cppn_generation.query_cppn_for_snake_shape(genome, config, self.corners[n], self.position_information, self.args, self.block_list)
            else:
                shape = cppn_generation.query_cppn_for_shape(genome, config, self.corners[n], self.position_information, self.args, self.block_list)

            shape_set = (list(set(map(lambda x: BlockType.values()[x.type], shape))))
            print(genome.block_list)

            if self.args.BLOCK_LIST_EVOLVES:
                minecraft_structures.place_blocks_in_block_list(genome.block_list,self.client,self.corners[n],self.position_information,shape_set,self.args.ONLY_SHOW_PLACED)
            # fill the empty space with the evolved shape
            self.client.spawnBlocks(Blocks(blocks=shape))
            # Place the fences where the shape will appear
            minecraft_structures.place_fences(self.client, self.position_information, self.corners[n])

        if self.args.IN_GAME_CONTROL:
            (on_block_positions,next_block_positions) = minecraft_structures.player_selection_switches(self.client, self.position_information, self.corners)

            selected = [False for _ in range(config.pop_size)]
            player_select_done = False
            
            while not player_select_done: #player is still selecting
               
                # constantly reads the position right below the redstone lamp
                # to see if the player has switched on a lever
                for i in range(config.pop_size):
                    first = on_block_positions[i]
                    blocks = self.client.readCube(Cube(
                        min=Point(x=first[0], y=first[1], z=first[2]),
                        max=Point(x=first[0], y=first[1], z=first[2])
                    ))
                    selected[i] = blocks.blocks[0].type == REDSTONE_BLOCK

                player_select_done = False
                j = 0
                # Checks the hidden Piston Heads associated with each next generation switch. 
                # If any one is sensed, then player selection is done 
                while not player_select_done and j < config.pop_size:
                    pressed = next_block_positions[j]
                    done_button = self.client.readCube(Cube(
                        min=Point(x=pressed[0], y=pressed[1], z=pressed[2]),
                        max=Point(x=pressed[0], y=pressed[1], z=pressed[2])
                    ))
                    player_select_done = done_button.blocks[0].type == PISTON_HEAD
                    j += 1
                    
                if self.args.BLOCK_LIST_EVOLVES:
                    # TODO: This will currently only work with in-game selection, but not with console-based selection. Need to fix.

                    # Reads in the blocks and stores them
                    read_current_blocks=minecraft_structures.read_current_block_options(self.client,self.corners,self.position_information)

                    # Compares each index of the block lists of the genome to what was read in.
                    for n, (_, genome) in enumerate(genomes):
                        if(genome.block_list != read_current_blocks[n]):
                            for i in range(len(genome.block_list)):
                                # If there was a difference, and it wasn't air, it replaces the blocks in the block_list and regenerates the structure 
                                if genome.block_list[i] != read_current_blocks[n][i] and read_current_blocks[n][i] != AIR:
                                    print(genome.block_list)
                                    # print("Genome {} swaps {} for {}".format(genome.key, BlockType.keys()[genome.block_list[i]], BlockType.keys()[read_current_blocks[n][i]]))
                                    genome.block_list[i]=read_current_blocks[n][i]
                                    shape = cppn_generation.query_cppn_for_shape(genome, config, self.corners[n], self.position_information, self.args, self.block_list)
                                    self.client.spawnBlocks(Blocks(blocks=shape))

        else:
            # Controlled externally by keyboard

            # Creates a string that is the user's input, and the converts it to a list
            vals = input("Select the ones you like:")
            split_vals = vals.split(' ')
            selected_vals = list(map(int,split_vals))

            # Initialize to all False
            selected = [False for i in range(config.pop_size)]
            # Then set to True for the items that are selected
            for ind in selected_vals:
                selected[ind] = True
        
        print("Selected: {}".format(selected))

        for n, (genome_id, genome) in enumerate(genomes):
            if selected[n]:
                genome.fitness = 1.0
            else:
                genome.fitness = 0.0
            print("{}. {}: {}".format(n,genome_id,genome.fitness))

        if self.args.USE_ELITISM:
            # To assure that all selected individuals survive, the elitism setting is changed
            elite_count = int(sum(map(lambda b : 1 if b else 0, selected)))
            print("{} elite survivors".format(elite_count))
            config.reproduction_config.elitism = elite_count

    # End of MinecraftBreeder                                                                                                            

if __name__ == '__main__':
    print("Do not launch this file directly. Launch main.py instead.")