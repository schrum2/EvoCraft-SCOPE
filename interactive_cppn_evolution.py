"""
Code originally taken from the offline simplified version of Picbreeder
that comes with NEAT-Python. Just wanted a starting point for evolving CPPNs.
Modifying the code to apply to Minecraft.
"""
# Are these still needed?
from asyncio.windows_events import NULL
from http import client
import math
import os
import pickle

# For CPPNs and NEAT
import neat
import custom_genomes as cg

# for Minecraft
import grpc
import minecraft_pb2_grpc
from minecraft_pb2 import *

# For utility functions
import util

# For minecraft structures
import minecraft_structures

# For CPPN generations
import cppn_generation

# For InteractiveStagnation class
import neat_stagnation

class MinecraftBreeder(object):
    def __init__(self, args, block_list):
        """
        Construct a class for evolving Minecraft shapes
        interactively. The shapes are generated by CPPNs.

        Parameters:
        args (argparse.Namespace): Command line parameter bundle
        block_list ([int]): List where each int represents a Minecraft block type.
                            This will be empty if block lists are maintained within
                            each genome rather than shared among them.
        """
        self.args = args
        self.block_list = block_list

        self.position_information = dict()
        self.position_information["startx"] = 0
        self.position_information["starty"] = 5
        self.position_information["startz"] = 0
        self.position_information["xrange"] = self.args.XRANGE
        self.position_information["yrange"] = self.args.YRANGE
        self.position_information["zrange"] = self.args.ZRANGE

        # Connect to Minecraft server
        channel = grpc.insecure_channel('localhost:5001')
        self.client = minecraft_pb2_grpc.MinecraftServiceStub(channel)

        # Restore ground at the start of evolution
        minecraft_structures.restore_ground(self.client, self.position_information, self.args.POPULATION_SIZE, self.args.SPACE_BETWEEN)

        # Figure out the lower corner of each shape in advance
        self.corners = []
        for n in range(self.args.POPULATION_SIZE):
            corner = (self.position_information["startx"] + n*(self.position_information["xrange"]+2+self.args.SPACE_BETWEEN), self.position_information["starty"], self.position_information["startz"])
            self.corners.append(corner)
            # Place the numbers just once. Only works for 0-9
            minecraft_structures.place_number(self.client,self.position_information,corner,n)

        self.generation = 0
        
        # Don't try any multithreading yet, but consider for later
        self.num_workers = 1


    def eval_fitness(self, genomes, config):
        """
        This function is expected by the NEAT-Python framework.
        It takes a population of genomes and configuration information,
        and assigns fitness values to each of the genome objects in
        the population. Nothing is returned, since the genomes themselves
        are modified.
        
        Parameters:
        genomes ([DefaultGenome]): list of CPPN genomes
        config  (Config): NEAT configurations
        """            
        minecraft_structures.clear_area(self.client, self.position_information, self.args.POPULATION_SIZE, self.args.SPACE_BETWEEN)                                                                                                               
        selected = []
        
        # This loop could be parallelized
        for n, (genome_id, genome) in enumerate(genomes):
            # Initially, none are selected
            selected.append(False)
            if self.args.BLOCK_LIST_EVOLVES:
                minecraft_structures.place_blocks_in_block_list(genome.block_list,self.client,self.corners[n], self.position_information,n)
            # See how CPPN fills out the shape
            print("{}. {}: ".format(n,genome_id), end = "") # Preceding number before info from query
            shape = cppn_generation.query_cppn_for_shape(genome, config, self.corners[n], self.position_information, self.args, self.block_list)
            # fill the empty space with the evolved shape
            self.client.spawnBlocks(Blocks(blocks=shape))
            # Place the fences where the shape will appear
            minecraft_structures.place_fences(self.client, self.position_information, self.corners[n])

        if self.args.IN_GAME_CONTROL:
            (on_block_positions,next_block_positions) = minecraft_structures.player_selection_switches(self.client, self.position_information, self.corners)

            selected = [False for _ in range(config.pop_size)]
            player_select_done = False
            
            while not player_select_done: #player is still selecting
               
                # constantly reads the position right below the redstone lamp
                # to see if the player has switched on a lever
                for i in range(config.pop_size):
                    first = on_block_positions[i]
                    blocks = self.client.readCube(Cube(
                        min=Point(x=first[0], y=first[1], z=first[2]),
                        max=Point(x=first[0], y=first[1], z=first[2])
                    ))
                    selected[i] = blocks.blocks[0].type == REDSTONE_BLOCK

                player_select_done = False
                j = 0
                # Checks the hidden Piston Heads associated with each next generation switch. 
                # If any one is sensed, then player selection is done 
                while not player_select_done and j < config.pop_size:
                    pressed = next_block_positions[j]
                    done_button = self.client.readCube(Cube(
                        min=Point(x=pressed[0], y=pressed[1], z=pressed[2]),
                        max=Point(x=pressed[0], y=pressed[1], z=pressed[2])
                    ))
                    player_select_done = done_button.blocks[0].type == PISTON_HEAD
                    j += 1
                    
                # This is causing problems where the blocks in new shapes do not match what they originally were
                if self.args.BLOCK_LIST_EVOLVES:
                    # TODO: This will currently only work with in-game selection, but not with console-based selection. Need to fix.
                    read_current_blocks=minecraft_structures.read_current_block_options(self.client,self.corners,self.position_information)

                    for n, (_, genome) in enumerate(genomes):
                        if(genome.block_list != read_current_blocks[n]):
                            #print(genome.key)
                            #print(genome.block_list)
                            for i in range(len(genome.block_list)):
                                if genome.block_list[i] != read_current_blocks[n][i] and read_current_blocks[n][i] != AIR:
                                    print("Genome {} swaps {} for {}".format(genome.key, BlockType.keys()[genome.block_list[i]], BlockType.keys()[read_current_blocks[n][i]]))
                                    genome.block_list[i]=read_current_blocks[n][i]

                            #print("---------------------------------------------")
                                                     

 
                #print(selected)

        else:
            # Controlled externally by keyboard

            # Creates a string that is the user's input, and the converts it to a list
            vals = input("Select the ones you like:")
            split_vals = vals.split(' ')
            selected_vals = list(map(int,split_vals))

            # Initialize to all False
            selected = [False for i in range(config.pop_size)]
            # Then set to True for the items that are selected
            for ind in selected_vals:
                selected[ind] = True
        
        print("Selected: {}".format(selected))

        for n, (genome_id, genome) in enumerate(genomes):
            if selected[n]:
                genome.fitness = 1.0
            else:
                genome.fitness = 0.0
            print("{}. {}: {}".format(n,genome_id,genome.fitness))

        if self.args.USE_ELITISM:
            # To assure that all selected individuals survive, the elitism setting is changed
            elite_count = int(sum(map(lambda b : 1 if b else 0, selected)))
            print("{} elite survivors".format(elite_count))
            config.reproduction_config.elitism = elite_count

    # End of MinecraftBreeder

# Various functions

def run(args):
    # If the block list evolves, customGenome is used. Otherwise it's the Default 
    if not args.BLOCK_LIST_EVOLVES:
        # Contains all possible blocks that could be placed, if the block list does not evolve, can be edited to have any blocks here
        block_list = [REDSTONE_BLOCK,PISTON,STONE, SLIME] # TODO: Make this a command line parameter somehow?
        genome_type = neat.DefaultGenome
        config_file = 'cppn_minecraft_config'
        block_list_length = len(block_list)
    else:
        block_list = [] # Won't be used, but parameter is still needed
        genome_type = cg.CustomBlocksGenome
        config_file = 'cppn_minecraft_custom_blocks_config'
        block_list_length = args.NUM_EVOLVED_BLOCK_LIST_TYPES
        cg.BLOCK_CHANGE_PROBABILITY = args.BLOCK_CHANGE_PROBABILITY
        #print("Set BLOCK_CHANGE_PROBABILITY to {}".format(cg.BLOCK_CHANGE_PROBABILITY))

    mc = MinecraftBreeder(args,block_list)

    # Determine path to configuration file.
    local_dir = os.path.dirname(__file__)
    config_path = os.path.join(local_dir, config_file)

    # Note that we provide the custom stagnation class to the Config constructor.
    config = neat.Config(genome_type, neat.DefaultReproduction,
                         neat.DefaultSpeciesSet, neat_stagnation.InteractiveStagnation,
                         config_path)

    config.pop_size = args.POPULATION_SIZE
    # Changing the number of CPPN outputs after initialization. Could cause problems.
    config.genome_config.num_outputs = block_list_length+1
    config.genome_config.output_keys = [i for i in range(config.genome_config.num_outputs)]

    pop = neat.Population(config)

    # Add a stdout reporter to show progress in the terminal.
    pop.add_reporter(neat.StdOutReporter(True))
    stats = neat.StatisticsReporter()
    pop.add_reporter(stats)

    # Evolve forever: TODO: Add use means of stopping
    try:
        while True:
            mc.generation = pop.generation + 1
            pop.run(mc.eval_fitness, 1)
    finally:
        # Clear and reset lots of extra space on exit/crash unless KEEP_WORLD_ON_EXIT is true. Population size doubled to clear more space
        if not args.KEEP_WORLD_ON_EXIT:
            minecraft_structures.restore_ground(mc.client, mc.position_information, mc.args.POPULATION_SIZE*2, mc.args.SPACE_BETWEEN)
            minecraft_structures.clear_area(mc.client, mc.position_information, mc.args.POPULATION_SIZE*2, mc.args.SPACE_BETWEEN)                                                                                                               
            # Clear space in the air to get rid of numbers
            mc.position_information["starty"] = mc.position_information["starty"]+mc.position_information["yrange"]
            minecraft_structures.clear_area(mc.client, mc.position_information, mc.args.POPULATION_SIZE*2, mc.args.SPACE_BETWEEN)                                                                                                               

if __name__ == '__main__':
    print("Do not launch this file directly. Launch main.py instead.")