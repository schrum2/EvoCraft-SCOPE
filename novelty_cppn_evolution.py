# For CPPNs and NEAT
import neat
import custom_genomes as cg

# for Minecraft
import grpc
import minecraft_pb2_grpc
from minecraft_pb2 import *

# For minecraft structures
import minecraft_structures

# For CPPN generations
import cppn_generation

# For novelty search
import novelty_characterizations as nc
import novelty_distance_metrics as ndm
import numpy as np
import random
import os
import pickle

class NoveltyMinecraftBreeder(object):
    def __init__(self, args, block_list):
        """
        Construct a class for evolving Minecraft shapes
        in an automatic manner (not interactively). 
        The shapes are generated by CPPNs.

        Parameters:
        args (argparse.Namespace): Command line parameter bundle
        block_list ([int]): List where each int represents a Minecraft block type.
                            This will be empty if block lists are maintained within
                            each genome rather than shared among them.

        Return:
        self.loaded_all_blocks (list of blocks): A list containg all blocks that were
                                                 generated when loading. Used to clear
        """
        self.args = args
        self.block_list = block_list
        self.archive = []
        self.random_threshold = args.NOVELTY_RANDOM_SCORE
        self.save_archive = args.SAVE_NOVELTY
        self.save_counter = 0
        self.loaded_all_blocks = []

        self.position_information = dict()
        self.position_information["startx"] = 0
        self.position_information["starty"] = 5
        self.position_information["startz"] = 0
        self.position_information["xrange"] = self.args.XRANGE
        self.position_information["yrange"] = self.args.YRANGE
        self.position_information["zrange"] = self.args.ZRANGE

        # Connect to Minecraft server
        channel = grpc.insecure_channel('localhost:5001')
        self.client = minecraft_pb2_grpc.MinecraftServiceStub(channel)

        # Restore ground at the start of evolution
        minecraft_structures.restore_ground(self.client, self.position_information, self.args.POPULATION_SIZE, self.args.SPACE_BETWEEN)
        
        # Gets the distance metric here to calculate the max, and to be used later on in the code
        self.distance_metric = getattr(ndm, self.args.NOVELTY_DISTANCE)

        zeroes = np.zeros(self.args.XRANGE*self.args.YRANGE*self.args.ZRANGE)
        if(self.args.NOVELTY_DISTANCE=="custom_hamming_distance"):
            zeroes+=5
        ones = np.ones(self.args.XRANGE*self.args.YRANGE*self.args.ZRANGE)
        self.max_distance = self.distance_metric(zeroes, ones)
        # print("Compare {} to {} to get {}".format(zeroes.ravel(), ones.ravel(), self.max_distance))

        # Figure out the lower corner of each shape in advance
        self.corners = []
        for n in range(self.args.POPULATION_SIZE):
            corner = (self.position_information["startx"] + n*(self.position_information["xrange"]+2+self.args.SPACE_BETWEEN), self.position_information["starty"], self.position_information["startz"])
            self.corners.append(corner)

        self.query_cppn = cppn_generation.query_cppn_for_snake_shape if self.args.EVOLVE_SNAKE else cppn_generation.query_cppn_for_shape

        self.generation = 0

        base_path = '{}'.format(self.args.BASE_DIR)
        dir_exists = os.path.isdir(base_path)
        if not dir_exists:
            os.mkdir(base_path)
    
        # Makes a sub dir too
        sub_path = '{}/{}{}'.format(base_path,self.args.EXPERIMENT_PREFIX,self.args.RANDOM_SEED)
        dir_exists = os.path.isdir(sub_path)
        if not dir_exists:
            os.mkdir(sub_path)
                        
        # Makes one more method
        pop_path = '{}/archive/'.format(sub_path)
        dir_exists = os.path.isdir(pop_path)
        if not dir_exists:
            os.mkdir(pop_path)


    def eval_fitness(self, genomes, config):
        """
        This function is expected by the NEAT-Python framework.
        It takes a population of genomes and configuration information, 
        and assigns characterizations to each of the genome objects in
        the population. These characterizations are then used to ccaluclate
        the distance from themselves to the other ojects in the archive. 
        The idea here is to add only novel entities into the archive.
        Nothing is returned, since the genomes themselves
        are modified.

        Parameters:
        genomes ([DefaultGenome]): list of CPPN genomes
        config  (Config): NEAT configurations
        """    
        # Clears space and creates list to be used later in the code    
        position_information_copy = self.position_information.copy()
        position_information_copy["starty"] = self.position_information["starty"]+self.position_information["yrange"]
        minecraft_structures.clear_area(self.client, position_information_copy, self.args.POPULATION_SIZE*2, self.args.SPACE_BETWEEN, self.args.MAX_SNAKE_LENGTH)                                                                                                               
        all_blocks = []                                                                                                             
        new_archive_entries = []
        print(self.generation)
        # This loop could be parallelized
        for n, (genome_id, genome) in enumerate(genomes):
            # If the number of individuals has grown beyond the original size,
            # more corners need to be added to reserve a slot in the world for the shape.
            if n >= self.args.POPULATION_SIZE:
                corner = (self.position_information["startx"] + n*(self.position_information["xrange"]+2+self.args.SPACE_BETWEEN), self.position_information["starty"], self.position_information["startz"])
                self.corners.append(corner)

            # See how CPPN fills out the shape
            print("{}. {}: ".format(n,genome_id), end = "") # Preceding number before info from query
            shape = self.query_cppn(genome, config, self.corners[n], self.position_information, self.args, self.block_list)
            # fill the empty space with the evolved shape
            self.client.spawnBlocks(Blocks(blocks=shape))
            all_blocks.extend(shape)
            
            # Gets type of characterization and distance metric to test for
            characterization = getattr(nc, self.args.NOVELTY_CHARACTER)
            # Creates list filled with characterization values
            character_list = characterization(self.client, self.position_information, self.corners[n], self.args)
            genome.fitness = self.max_distance # A sufficiently large value that cannot be attained

            for a in self.archive:
                # Convert to arrays to calculate the euclidean disatnce
                character_list_arr = np.array(character_list)
                a_arr = np.array(a)
                adist = self.distance_metric(character_list_arr, a_arr) # Euclidean distance
                # For debugging
                # print("Compare {} to {} to get {}".format(character_list_arr.ravel(), a_arr.ravel(), adist))
                genome.fitness = min(genome.fitness, adist) # Fitness is smallest value 

            # Only if random threshold is hit, then added to the archive. Random threshold based on command line param
            if random.random() < self.random_threshold:
                new_archive_entries.append(character_list)

                # Saves the genomes in a file based on a counter. Based on command line param
                if self.save_archive:
                    with open("{}/{}{}/archive/shape{}".format(self.args.BASE_DIR,self.args.EXPERIMENT_PREFIX,self.args.RANDOM_SEED,self.save_counter),'wb') as handle:
                        pickle.dump(genome, handle)
                    print("shape{} added to {}/{}{}/archive".format(self.save_counter,self.args.BASE_DIR,self.args.EXPERIMENT_PREFIX,self.args.RANDOM_SEED))
                    self.save_counter+=1 # Increases counter for next shape
                
            print('{0} archive entries'.format(len(self.archive)))
            if self.args.EVOLVE_SNAKE and (not self.args.LOAD_NOVELTY or (self.generation < self.args.MAX_NUM_GENERATIONS or not self.args.KEEP_WORLD_ON_EXIT)):     
                for s in all_blocks:
                    s.type = AIR
                self.client.spawnBlocks(Blocks(blocks=all_blocks))

            # If loading, save ALL blocks generated here, to be returned
            if self.args.LOAD_NOVELTY:
                self.loaded_all_blocks.extend(shape)
            
        self.generation+=1

        # Adds new entries to archive
        self.archive.extend(new_archive_entries)
        return self.loaded_all_blocks 
    # End of NoveltyMinecraftBreeder                                                                                                            

if __name__ == '__main__':
    print("Do not launch this file directly. Launch main.py instead.")