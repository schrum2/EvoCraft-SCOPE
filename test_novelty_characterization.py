import novelty_characterizations as nc
import minecraft_structures as ms

import argparse
import pytest

import grpc
import minecraft_pb2_grpc
from minecraft_pb2 import *

# Used for setup and teardown
@pytest.fixture(autouse=True)
def run_around_tests():
        channel = grpc.insecure_channel('localhost:5001')
        client = minecraft_pb2_grpc.MinecraftServiceStub(channel)
        
        
        position_information = dict()
        position_information["startx"] = -100
        position_information["starty"] = 5
        position_information["startz"] = 250
        position_information["xrange"] = 4
        position_information["yrange"] = 4
        position_information["zrange"] = 4 

        corners = []
        for n in range(10):
            corner = (position_information["startx"] + n*(position_information["xrange"]+2+1), position_information["starty"], position_information["startz"])
            corners.append(corner)

        x = position_information["startx"]
        y = position_information["starty"]
        z = position_information["startz"]
        ms.clear_area(client, position_information, 10, 1, 5)

        # Shape1 is shape generated by hard coding it in
        shape1 = [
            # Bottom square
            Block(position=Point(x=x,y=y,z=z), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x+1,y=y,z=z), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x+2,y=y,z=z), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x+3,y=y,z=z), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x,y=y,z=z+1), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x,y=y,z=z+2), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x,y=y,z=z+3), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x+1,y=y,z=z+3), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x+2,y=y,z=z+3), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x+3,y=y,z=z+3), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x+3,y=y,z=z+2), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x+3,y=y,z=z+1), type=GLOWSTONE, orientation=NORTH),
            # Top Square
            Block(position=Point(x=x,y=y+3,z=z), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x+1,y=y+3,z=z), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x+2,y=y+3,z=z), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x+3,y=y+3,z=z), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x,y=y+3,z=z+1), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x,y=y+3,z=z+2), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x,y=y+3,z=z+3), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x+1,y=y+3,z=z+3), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x+2,y=y+3,z=z+3), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x+3,y=y+3,z=z+3), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x+3,y=y+3,z=z+2), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x+3,y=y+3,z=z+1), type=GLOWSTONE, orientation=NORTH),
            # Sides
            Block(position=Point(x=x,y=y+1,z=z), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x,y=y+2,z=z), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x+3,y=y+1,z=z), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x+3,y=y+2,z=z), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x,y=y+1,z=z+3), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x,y=y+2,z=z+3), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x+3,y=y+1,z=z+3), type=GLOWSTONE, orientation=NORTH),
            Block(position=Point(x=x+3,y=y+2,z=z+3), type=GLOWSTONE, orientation=NORTH),
            # Inside cube
            Block(position=Point(x=x+1,y=y+1,z=z+1), type=COAL_BLOCK, orientation=NORTH),
            Block(position=Point(x=x+1,y=y+2,z=z+1), type=COAL_BLOCK, orientation=NORTH),
            Block(position=Point(x=x+1,y=y+1,z=z+2), type=COAL_BLOCK, orientation=NORTH),
            Block(position=Point(x=x+1,y=y+2,z=z+2), type=COAL_BLOCK, orientation=NORTH),
            Block(position=Point(x=x+2,y=y+1,z=z+1), type=COAL_BLOCK, orientation=NORTH),
            Block(position=Point(x=x+2,y=y+2,z=z+1), type=COAL_BLOCK, orientation=NORTH),
            Block(position=Point(x=x+2,y=y+1,z=z+2), type=COAL_BLOCK, orientation=NORTH),
            Block(position=Point(x=x+2,y=y+2,z=z+2), type=COAL_BLOCK, orientation=NORTH),
            ]

        client.spawnBlocks(Blocks(blocks=shape1))    

        x = position_information["startx"] + position_information["xrange"] + 3
        y = position_information["starty"]
        z = position_information["startz"]
        
        # Shape2 creates a block that has 4 different types of blocks in layers
        shape2 = []   
        for i in range(4):
            for xi in range(position_information["xrange"]):
                shape2.append(Block(position=Point(x=x + xi, y=y, z=z+i), type=CYAN_GLAZED_TERRACOTTA, orientation=NORTH))
                shape2.append(Block(position=Point(x=x + xi, y=y+2, z=z+i), type=GREEN_GLAZED_TERRACOTTA, orientation=NORTH))
                shape2.append(Block(position=Point(x=x + xi, y=y+1, z=z+i), type=MAGENTA_GLAZED_TERRACOTTA, orientation=NORTH))
                shape2.append(Block(position=Point(x=x + xi, y=y+3, z=z+i), type=BLACK_GLAZED_TERRACOTTA, orientation=NORTH))

        client.spawnBlocks(Blocks(blocks=shape2))


        x = position_information["startx"] + (position_information["xrange"] + 3)*2
        y = position_information["starty"]
        z = position_information["startz"]
        
        # Shape3 is a block made of only one type
        shape3 = []
        for i in range(4):
            for xi in range(position_information["xrange"]):
                for yi in range(position_information["yrange"]):
                    shape3.append(Block(position=Point(x=x + xi, y=y+yi, z=z+i), type=GOLD_BLOCK, orientation=NORTH))
                
        client.spawnBlocks(Blocks(blocks=shape3))


        x = position_information["startx"] + (position_information["xrange"] + 3)*3
        y = position_information["starty"]
        z = position_information["startz"]
        
        # Shape4 starts as a cube, then gets blocks taken out of it
        shape4 = []
        for i in range(4):
            for xi in range(3):
                for yi in range(4):
                    shape4.append(Block(position=Point(x=x + xi, y=y+yi, z=z+i), type=QUARTZ_STAIRS, orientation=NORTH))


        shape4.append(Block(position=Point(x=x+1, y=y + 1, z=z+1), type=AIR, orientation=NORTH))
        shape4.append(Block(position=Point(x=x+1, y=y + 2, z=z+1), type=AIR, orientation=NORTH))
        shape4.append(Block(position=Point(x=x+1, y=y + 3, z=z+1), type=AIR, orientation=NORTH))
        shape4.append(Block(position=Point(x=x+1, y=y, z=z+1), type=AIR, orientation=NORTH))
        shape4.append(Block(position=Point(x=x+2, y=y + 1, z=z+1), type=AIR, orientation=NORTH))
        shape4.append(Block(position=Point(x=x+2, y=y + 2, z=z+1), type=AIR, orientation=NORTH))
        shape4.append(Block(position=Point(x=x+2, y=y + 3, z=z+1), type=AIR, orientation=NORTH))
        shape4.append(Block(position=Point(x=x+2, y=y, z=z+1), type=AIR, orientation=NORTH))
        shape4.append(Block(position=Point(x=x+1, y=y + 1, z=z+2), type=AIR, orientation=NORTH))
        shape4.append(Block(position=Point(x=x+1, y=y + 2, z=z+2), type=AIR, orientation=NORTH))
        shape4.append(Block(position=Point(x=x+1, y=y + 3, z=z+2), type=AIR, orientation=NORTH))
        shape4.append(Block(position=Point(x=x+1, y=y, z=z+2), type=AIR, orientation=NORTH))
                    
        client.spawnBlocks(Blocks(blocks=shape4))

        yield # Signifes what runs after code. Before yield is set up, after is teardown
    
        ms.clear_area(client, position_information, 10, 1, 5)
        # Testing flying machine
        # shape5 = []
        # shape5.append(Block(position=Point(x=x+1, y=y, z=z), type=SLIME, orientation=NORTH))
        # shape5.append(Block(position=Point(x=x+2, y=y, z=z+1), type=SLIME, orientation=NORTH))
        # shape5.append(Block(position=Point(x=x+2, y=y, z=z), type=STICKY_PISTON, orientation=WEST))
        # shape5.append(Block(position=Point(x=x, y=y, z=z), type=OBSERVER, orientation=WEST))
        # shape5.append(Block(position=Point(x=x-1, y=y, z=z), type=QUARTZ_BLOCK, orientation=EAST))
        # shape5.append(Block(position=Point(x=x+1, y=y, z=z+1), type=STICKY_PISTON, orientation=EAST))
        # shape5.append(Block(position=Point(x=x+3, y=y, z=z+1), type=OBSERVER, orientation=EAST))
        # shape5.append(Block(position=Point(x=x+3, y=y, z=z+1), type=QUARTZ_BLOCK, orientation=EAST))

        # client.spawnBlocks(Blocks(blocks=shape5))
    # end run_around_tests

def test_presence_characterization():
    try:
        # Need client and position information here too in order to call the function right
        channel = grpc.insecure_channel('localhost:5001')
        client = minecraft_pb2_grpc.MinecraftServiceStub(channel)
        
        
        position_information = dict()
        position_information["startx"] = -100
        position_information["starty"] = 5
        position_information["startz"] = 250
        position_information["xrange"] = 4
        position_information["yrange"] = 4
        position_information["zrange"] = 4

        corners = []
        for n in range(10):
            corner = (position_information["startx"] + n*(position_information["xrange"]+2+1), position_information["starty"], position_information["startz"])
            corners.append(corner)

        # Doesn't need args in this charact. but still has as a param
        test_parser = argparse.ArgumentParser()
        
        test_parser.add_argument('--POTENTIAL_BLOCK_SET', type=str, default="test", metavar='',
                            help='block_set')
        
        args = test_parser.parse_args()
        
        # Goes in order Z,Y,X starting from the corner
        # For shape1, hard coded in
        assert nc.presence_characterization(client, position_information, corners[0], args) == [1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0,
         0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1]
        
        # For shape2, layered cube
        assert nc.presence_characterization(client, position_information, corners[1], args) == [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]

        #For shape3, solid cube
        assert nc.presence_characterization(client, position_information, corners[2], args) == [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        
        #For shape4, custom cube with blocks taken out
        assert nc.presence_characterization(client, position_information, corners[3], args) == [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0,
         1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    except:
        pytest.fail('Currently not connected to a minecraft server.')

def test_block_type_characterization():
    try:
        # Need client and position information here too in order to call the function right
        channel = grpc.insecure_channel('localhost:5001')
        client = minecraft_pb2_grpc.MinecraftServiceStub(channel)
        
        
        position_information = dict()
        position_information["startx"] = -100
        position_information["starty"] = 5
        position_information["startz"] = 250
        position_information["xrange"] = 4
        position_information["yrange"] = 4
        position_information["zrange"] = 4

        corners = []
        for n in range(10):
            corner = (position_information["startx"] + n*(position_information["xrange"]+2+1), position_information["starty"], position_information["startz"])
            corners.append(corner)

        # Doesn't need args in this charact. but still has as a param
        test_parser = argparse.ArgumentParser()
        
        test_parser.add_argument('--POTENTIAL_BLOCK_SET', type=str, default="test", metavar='',
                            help='block_set')
        
        args = test_parser.parse_args()
        
        # Goes in order Z,Y,X starting from the corner
        # For shape1, hard coded in
        # GLOWSTONE = 89, COAL_BLOCK = 39 AIR = 5
        assert nc.block_type_characterization(client, position_information, corners[0], args) == [89, 89, 89, 89, 89, 5, 5, 89, 89, 5, 5, 89, 89, 89, 89, 89, 89, 5, 5, 89, 5, 39, 39, 5,
         5, 39, 39, 5, 89, 5, 5, 89, 89, 5, 5, 89, 5, 39, 39, 5, 5, 39, 39, 5, 89, 5, 5, 89, 89, 89, 89, 89, 89, 5, 5, 89, 89, 5, 5, 89, 89, 89, 89, 89]
        
        # For shape2, layered cube
        # CYAN_GLAZED_TERRACOTTA = 48, MAGENTA_GLAZED_TERRACOTTA = 133, GREEN_GLAZED_TERRACOTTA = 98, BLACK_GLAZED_TERRACOTTA = 16
        assert nc.block_type_characterization(client, position_information, corners[1], args) == [48,48,48,48,133,133,133,133,98,98,98,98,16,16,16,16,48,48,48,48,133,133,133,133,98,98,98,
         98,16,16,16,16,48,48,48,48,133,133,133,133,98,98,98,98,16,16,16,16,48,48,48,48,133,133,133,133,98,98,98,98,16,16,16,16,]

        # For shape3, solid cube
        # GOLD_BLOCK = 91
        assert nc.block_type_characterization(client, position_information, corners[2], args) == [91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
         91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91]
        
        # For shape4, custom cube with blocks taken out
        # QUARTZ_STAIRS = 177 AIR = 5
        assert nc.block_type_characterization(client, position_information, corners[3], args) == [177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 5, 5, 177, 177, 5, 5,
         177, 177, 5, 5, 177, 177, 5, 5, 177, 177, 5, 177, 177, 177, 5, 177, 177, 177, 5, 177, 177, 177, 5, 177, 177, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
    except:
        pytest.fail('Currently not connected to a minecraft server.')

def test_composition_characterization():
    try:
        # Need client and position information here too in order to call the function right
        channel = grpc.insecure_channel('localhost:5001')
        client = minecraft_pb2_grpc.MinecraftServiceStub(channel)
        
        
        position_information = dict()
        position_information["startx"] = -100
        position_information["starty"] = 5
        position_information["startz"] = 250
        position_information["xrange"] = 4
        position_information["yrange"] = 4
        position_information["zrange"] = 4

        corners = []
        for n in range(10):
            corner = (position_information["startx"] + n*(position_information["xrange"]+2+1), position_information["starty"], position_information["startz"])
            corners.append(corner)

        # may need to delete or rework this. Not doinf anything now, but args is necessary to call
        test_parser = argparse.ArgumentParser()
        
        test_parser.add_argument('--POTENTIAL_BLOCK_SET', type=str, default="test", metavar='',
                            help='block_set')
        
        args = test_parser.parse_args()
        
        # Reads in order Z,Y,X starting from the corner
        # order for compoition is based on the list in block_sets,
        # Percentages of [GLOWSTONE,COAL_BLOCK,MAGENTA_GLAZED_TERRACOTTA,GREEN_GLAZED_TERRACOTTA,BLACK_GLAZED_TERRACOTTA,CYAN_GLAZED_TERRACOTTA,GOLD_BLOCK,QUARTZ_STAIRS]

        # For shape1, hard coded in
        assert nc.composition_characterization(client, position_information, corners[0], args) == [0.5, 0.125, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]

        # For shape2, layered cube
        assert nc.composition_characterization(client, position_information, corners[1], args) == [0.0, 0.0, 0.25, 0.25, 0.25, 0.25, 0.0, 0.0]

        # For shape3, solid cube
        assert nc.composition_characterization(client, position_information, corners[2], args) == [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0]
        
        # For shape4, custom cube with blocks taken out
        assert nc.composition_characterization(client, position_information, corners[3], args) == [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5625]
        

    except:
        pytest.fail('Currently not connected to a minecraft server.')
